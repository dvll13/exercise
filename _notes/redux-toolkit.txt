//postSlice.js
import { createSlice } from '@reduxjs/toolkit'

// createSlice (using the Immer library) lets us write "mutating" logic in our reducers
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    postAdded: {
      reducer(state, action) {
        state.push(action.payload)
      },
      prepare(title, content) {
        return {
          payload: {
            id: nanoid(),
            title,
            content
          }
        }
      }
    }
  }
})

/*
  console.log({ action }) ->
    {
      "type": "posts/addPost",
      "payload": {
        "title": "test",
        "content": "test text"
      }
    }
*/

//                                        (action type prefix, payload creation callback)
export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
  const response = await client.get('/fakeApi/posts')
  return response.data
})
// => 'posts/fetchPosts/pending', 'posts/fetchPosts/fulfilled'

export const selectAllPosts = (state) => state.posts.posts
export const selectPostById = (id) => (state) => state.posts.posts.find((post) => post.id === id)

export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions


//ADD
import { useDispatch } from 'react-redux'
import { nanoid } from '@reduxjs/toolkit'
import { addPost } from './postsSlice'

const dispatch = useDispatch()
const onSave = () => dispatch(addPost({ id: nanoid(), title, content }))


//LIST
import { useSelector } from 'react-redux'
import { selectPosts } from './postsSlice'

const posts = useSelector(selectPosts)


const orderedPosts = posts.slice().sort((a, b) => b.date.localeCompare(a.date)) // make a copy & order it by date DESC

await dispatch(addNewPost({ title, content, userId })).unwrap()
//Redux Toolkit adds a .unwrap() function to the returned Promise, which will return a new Promise that either has the actual action.payload value from a fulfilled action, or throws an error if it's the rejected action. This lets us handle success and failure in the component using normal try/catch logic.

const postsForUser = useSelector((state) => {
  const allPosts = selectAllPosts()
  return allPosts.filter((post) => post.user === userId)
})


------------
If an action needs to contain a unique ID or some other random value, always generate that first and put it in the action object. REDUCERS SHOULD NEVER CALCULATE RANDOM VALUES, because that makes the results unpredictable.
Fortunately, createSlice lets us define a "prepare callback" function when we write a reducer. The "prepare callback" function can take multiple arguments, generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. It should then return an object with the payload field inside. (The return object may also contain a meta field, which can be used to add extra descriptive values to the action, and an error field, which should be a boolean indicating whether this action represents some kind of error.)

createSlice and createAction can accept a "prepare callback" that returns the action payload
Reducers can contain whatever logic is needed to calculate the next state
Action objects should contain just enough info to describe what happened

it's always better to KEEP THE ACTION OBJECTS AS SMALL AS POSSIBLE, AND DO THE STATE UPDATE CALCULATIONS IN THE REDUCER. This also means that reducers can contain as much logic as necessary to calculate the new state.


It's often a good idea to encapsulate data lookups by writing REUSABLE SELECTORS. You can also create "memoized" selectors that can help improve performance.
Don't feel like you need to write selectors for every single field of your state. Try starting without any selectors, and add some later when you find yourself looking up the same values in many parts of your application code.

Alternately, extraReducers can also be an object. This is a legacy syntax - it's still supported, but we recommend the "BUILDER CALLBACK" syntax as it works better with TypeScript.

