# EXECUTION CONTEXT & CALL STACK

> Every JS code runs in an environment called **Execution Context**.

- By default every code is in the **Global (Default) Execution Context (GEC)**
- Inside `GEC` all code that is not wrapped in a `function` gets **executed**
- A **new `function`** gets its **new Execution Context**
  
> **Call Stack** - a collection of **all Execution Contexts**, where they **pile up** for each `function` call and are **removed** when the function returns. At the bottom is the **GEC**.

<br/>

### Execution Context Object contains 3 properties:
- **Variable Object** - contains function arguments, inner variable declarations, function declarations   
- **Scope chain** - contains the current variable objects, as well as variable objects of all its parents
- **`this` keyword/variable** - a var that each execution context gets

<br/>

### Execution Context Object PHASES:
- **Creation** phase:
  - creation of the **variable object**
    - the **`arguments`** object is created, containing all the arguments passed to the function
    - next is **HOISTING**:
      - code is scanned for **`function` declarations** and for each one, a property is created in the **variable object**, pointing to its function, so`functions` are made available **before** the execution phase starts
      - code is scanned for **`variable` declarations** and for each a property is created in the **variable object** and set to `undefined`, and will be defined in the `execution` phase
  - creation of the **scope chain**
  - determine the value of the **`this` variable**
- **Execution** phase - the code of the function that was generated by the current execution context is ran line by line

<br/>

### Scoping

> **Scope** - space/environment where a certain **variable** is declared and can be accessed

> **Lexical Scoping** - scoping is controlled by the **placement** of `functions` and `blocks` in the code

- **Global** scope - **outside** of any function or block. Variables declared in it are **global**
- **Function** / **Local** scope - each `function` creates a scope and the variables declared there are only accessible in it
- **Block** scope - from ES6, blocks `{...}` create a scope also
  - `let` and `const` variables (block scoped), declared in a Block scope, are accessible **only** inside it
  - `vars` (function scoped) though are scoped to the current `Function` or `Global` scope
  - in `strict mode` all `functions` are **block scoped** too

<br/>

### Scope Chain

 > **Variable Lookup** - if a variable can't be found in the current scope, the JS engine starts looking for it in the **parent scope**, then its parent scope, and so on (up in the Scope Chain).

<br/>

### `this` keyword

- in a **regular `function` call**: points to the **global** `window` object
- in a **method (fn attached to an object) call**: 
  - **regular** function - points to the **`object`** that is **calling** the method 
  - **arrow** function - points to the **upper** context 

In a Method	Owner -> Object(Which invoked method)  
Alone -> Global Object  
In a function (Default Mode) -> Global Object  
In a function (Strict Mode) -> undefined  
In an event -> the target of the event

  ```js
  const obj1 = {
    a: 1,
    b: this.a,
    f1() { console.log(this.a, obj1.a, this.b, this) } // 1 1 undefined {...obj1}
    f2: function() {
      console.log(this) // { ...obj1 }
      
      function f() { console.log(this) } // function declaration
      f() // it's a regular fn call => Window 
      
      const fn = function() {} // function expression
    },
    f3: () => { console.log(this) }, // Window
  }

  // method borrowing:
  var obj2 = { a: 2 }
  obj2.f1 = obj1.f1
  obj2.f1() // 2 1 undefined {..obj2s}
  ```

- `this` is **not assigned** a value until the function where it is defined is **called**

> A **constructor** is a fn that allows us to create a blueprint, based on which we can create instances using the **`new`** keyword. In the `constructor` the `this` keyword refers to the newly created `object`.
> 
```js
// construction function should start with a capital letter
const SomeConstructorFn = function (firstProp, secondProp) {
  this.firstProp = firstProp
  this.secondProp = secondProp
}

const obj1 = new SomeConstructorFn('first', 2) // => obj1 { firstProp: "first", secondProp: 2 }
```

[eyeballing this](https://gist.github.com/zcaceres/2a4ac91f9f42ec0ef9cd0d18e4e71262)

<br/><br/><br/>

# Primitive and reference types

```js
// these are primitive types too:
typeof undefined // undefined
typeof null // object (NB! should be checked with `someVar === null` instead)

typeof someFunction // function

typeof someArray // object
typeof someObject // object
// BETTER:
instanceof Array // true
instanceof Object // true
instanceof Function // true
// since all the reference types are children of Object, hence Array/Function instanceof Object -> true
```

> **De-referencing** an object - when we **remove** all pointers to a memory allocated space for an object, then the JS engine will clean it from the memory (garbage collect). This can be done by **`obj1 = null`**.

> **Wrapper types** for primitive values - JS uses them to allow us to call methods on them like `someString.substring()`. Adds the wrapper when it notices the method call and destroys it immediately, that's why `someString instanceof String === false`

<br/><br/><br/>

# Equality (===)

> `==` - converts the type of the right part to the left and then compares

> `===` compares the value **and the type**

<br/><br/><br/>


# CLOSURE
_allows an inner function to to have access to the outer function's variables and use them as "private" ones_
```js
const getAdd = () => {
  let foo = 1
  
  return () => {
    foo = foo + 1
    return foo
  }
}

const add = getAdd()

OR:

const add = (const getAdd = () => {
  let foo = 1
  
  return () => {
    foo = foo + 1
    return foo
  }
})() // Immediately Invoked Function Expression (IIFE)

===

console.log(add()) // 2
console.log(add()) // 3
console.log(add()) // 4
```	
<br/><br/>


# VARS
- `let`, `const` -> scoped in the current context (block-scoped variables), unlike `var`  
- `var` variables can be redeclared multiple times without causing an error, unlike `let` and `const`; they have **global and function** scopes
<br/><br/>


# FUNCTIONS

There are 2 ways to **define** them:
  - **declaration** - `function a() {...}` -> **hoisting** (js engine pushes it to the top of the scope)
  - **expression** - `const a = function() {...}` -> **no hoisting** because the js engine doesn't know the name of the function ahead of time

> **`arguments`** - stores all passed params even if they are not declared

> **`someFunction.length`** - returns the number of **named** params

- **`call()`** - `someFunc.call(objectToPassToThis, ...arguments)`, no params -> passes the global scope to `this`. Allows a function to be defined outside of the objects that will invoke it
- **`apply()`** -  `someFunc.call(objectToPassToThis, [...arguments])` - same as `call` but the only difference is that it accepts an array of arguments instead of passing them one by one
- **`bind()`** - `const boundFn = fn.bind(obj1, ...args)` - returns a function in which `this = obj1`; `args` could also be passed to the `boundFn`
<br/><br/>


# ARROW FUNCTIONS
_anonymous function assigned to a variable_

They don't have their own context (`this` points to the upper enclosing context).  
A function becomes a part of the global window context, so with an arrow function `this` points to it.

Arrow functions handle `this` in a different way from regular functions:
* Arrow function - `this` represents the object that **defined** the arrow function.  
* In regular functions this keyword represented the object that **called** the function (the executer), which could be the window, the document, or whatever.

In short , in arrow function this represents the **definition** context while in regular function this represents the **execution** context.

```js
const obj = {
  props: ['prop1', 'prop2'], 
  
  printProps: function() {
    console.log(this) // this -> obj (since the function is part of the object)
    
    setTimeout(function() { 
      console.log(this) // this -> window
    }, 1000)

    setTimeout(() => console.log(this), 2000) // this -> obj
  },

  printPropsA: () => {
    console.log(this) // this -> window
    
    setTimeout(function() { 
      console.log(this) // this -> window
    }, 1000)

    setTimeout(() => console.log(this), 2000) // this -> window
  }
}
```

> Arrow functions **CANNOT** be used as **constructors** : 
This is because of how Arrow Functions use the `this` keyword. JS will simply throw an error if it sees an arrow function being invoked as a "constructor".

```js
function personCreator(name) {
   this.name = name
}
const person1 = new personCreator('John') // personCreatorÂ {name: 'John'}
```

The `new` keyword do some of its magic and makes the `this` keyword that is inside of `personCreator` to be initially an empty object instead of referencing the global object. After that, a new property called `name` is created inside that empty this object, and its value will be `'John'`. At the end, the `this` object is returned.

As we see, the `new` keyword changed the value of `this` from referencing the `global` object to `now` be an empty object `{}`.

**Arrow functions do not allow their `this` object to be modified**. Their `this` object is **always** locked to the value of the `this` of the scope where they were statically **created**. This is called **Static Lexical Scope**. That is why you **cannot** do operations like `bind`, `apply`, or `call` with arrow functions. 

_A **lexical scope** is just the area where a function is created._

- `this` keywords specifics from above
- Also **no `arguments`** keyword  
- No **`new`** keyword

Arrow functions **don't have** their own `this` or `arguments` binding. Instead, those identifiers are resolved in the **lexical scope** like any other variable. That means that inside an arrow function, `this` and `arguments` refer to the values of `this` and `arguments` in the environment the arrow function is **defined**

<br/><br/>


# REGULAR (R) VS ARROW (A) FUNCTIONS

- `this` and `arguments`:
  - **no `this` and `arguments` binding in A** - they are resolved in the _lexical scope_ like any other variable (the env in which the A is defined). No matter how or where being executed, `this` value inside of an arrow function **always** equals this value from the **outer function**.
  - **`this` in R**:
    - during a _simple invocation_ the value of `this` equals to the **global object** (or `undefined` if the function runs in `strict mode`)
    - during a _method invocation_ the value of `this` is the **object owning the method**
    - during an _indirect invocation_ using `myFunc.call(thisVal, arg1, ..., argN)` or `myFunc.apply(thisVal, [arg1, ..., argN])` the value of this equals to the **first argument**
    - during a _constructor invocation_ using new keyword this equals to the newly created **instance**
- **R are constructible** and they can be called with the `new` keyword
- **no duplicate params** in **A**, while **R** allow it if not in `strict mode`

[https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/](https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/)

[https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-interchangeable](https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-interchangeable)

<br/><br/>

# OBJECTS

> **`obj1.hasOwnProperty('prop1')`** method - check if a property is present and **not inherited**

> **`delete obj.prop`** - **removes a property** from an object; if no more references to the same property are held, it is eventually released automatically. returns `true` for all cases except when the property is an own non-configurable property, in which case, `false` is returned in non-strict mode

> **`obj1.propertyIsEnumerable('prop1')`**- not all props are enumerable (get cycled in loops), can be checked with this method


## Accessors
```js
var a = {
  _name: 'one',
  _second: 'once',
  set name(value) { this._name = value },
  get name() { return this._name }
}

console.log(a.second) // undefined
console.log(a._name) // one
console.log(a.name) // one
a.name = 'two'
console.log(a.name) // two
```

> If only a **getter** is defined, then the prop will be **read-only**.


## Property descriptors
> they allow to define an object property in more detail.  

<br/>

> `Object.defineProperty(obj1, prop, descriptor): obj1` - This method allows a precise **addition to or modification of a property** on an object. Normal property addition through assignment creates properties which show up during property enumeration (`for...in` loop or `Object.keys` method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults. By default, values added using `Object.defineProperty()` are immutable and not enumerable.



```js
const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 4,
  writable: false
});

object1.property1 = 7;
// throws an error in strict mode

console.log(object1.property1);
// expected output: 4
```
<br/>

Property descriptors present in objects come in two main flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions.  
<br/>

Both data and accessor descriptors are objects. They share the following **optional keys**:
- `configurable` [false]
  - the **type** of this property cannot be changed between data property and accessor property
  - the property may not be **deleted**
  - other **attributes of its descriptor** cannot be changed (however, if it's a data descriptor with `writable: true`, the value can be changed, and `writable` can be changed to `false`)
  - once set to `true` **can't be changed back** to `false`
- `enumerable` [false] - should this property shows up during enumeration of the properties on the corresponding object
- `value` [undefined] - the value of the property
- `writable` [false] - should the value associated with the property may be changed with an assignment operator  

**Accessor** descriptor **additional** keys:
- `get`
- `set`

```js
const o = {}; 
const bValue = 38;

Object.defineProperty(o, 'b', {
  get() { return bValue; },
  set(newValue) { bValue = newValue; },
  enumerable: true,
  configurable: true
});

o.b; // 38
o.b = 22 // Uncaught TypeError: Assignment to constant variable.
```
> A **method** is a property with a function as a value.
```js
{ get: function()  <=> get() {} }
```

<br/><br/>


## Constructor

> A function using which we can **create objects** with the same properties and methods

```js
function FlightNoParams() {}
function Flight(airlines, flightNumber) {
  this.airlines = airlines
  this.flightNumber = flightNumber
  this.display = function() { console.log(this.airlines, this.flightNumber) }

  // Object.defineProperty() can be used in the constructor
}

const flight1 = new FlightNoParams // parenthesis can be omitted when there are no params
const flight2 = new Flight('American Airlines', 'AA123')
console.log(flight2 instanceof Flight) // true
console.log(flight2.constructor === Flight) // true
```

<br/><br/>


## Prototypes

> Every **function** has a reference type property called `prototype` and if we create `objects` using this `function` they will have a property `prototype` that will point to the `function`'s `prototype`.

**Advantages**:
- if we save a method in the `prototype` of the `function` then the `objects` using it will point to it and **save memory**. we can reuse methods and properties on the prototypes. _By using prototype property on the constructor function,  Prototype will enable us to easily **define methods to all instances** of the instances while saving memory. What's great is that the method will be applied to the prototype of the object, so it is only stored in the memory once, because objects coming from the same constructor point to one common prototype object. In addition to that, all instances of userOne or userTwo will have access to that method. Thus, we will be able to save quite a good amount of memory compared to the constructor approach. Apart from low memory usage, the prototype approach is obviously faster in execution when creating new object instances since no time is spent on re-declaring any methods._
- we can use **prototype chaining** to implement **inheritance**

`__proto__` | `[[Prototype]] shows what's in the prototype

```js
const passenger = { name: 'John' }

console.log('name' in passenger) // true
console.log(passenger.hasOwnProperty('name')) // true
console.log('hasOwnProperty' in passenger) // true
console.log(passenger.hasOwnProperty('hasOwnProperty')) // false - because it comes from the Object.prototype.hasOwnProperty(). Every object gets access to it.
console.log(Object.prototype.hasOwnProperty('hasOwnProperty')) // true
```

When an object prop is called JS Engine first checks for it in the **object**, then the **prototype** and if still not found, returns `undefined`.

```js
function Flight(airlines, flightNumber) {
  this.airlines = airlines
  this.flightNumber = flightNumber
  // this.display = function() { console.log(this.airlines, this.flightNumber) }
}

// moving the function to the prototype to save memory
// Flight.prototype.display = function() { console.log(this.airlines, this.flightNumber) }
Flight.prototype = {
  constructor: Flight, // good practice
  display: function() { console.log(this.airlines, this.flightNumber) },
  toString: function() {console.log(`Flight ${this.flightNumber}!`)}
}

const flight1 = new Flight('American Airlines', 'AA123')
const flight2 = new Flight('South West', 'SW123')

console.log(flight1.display === flight2.display) // true
console.log(flight1.toString()) // Flight AA123!

console.log(flight1 instanceof Flight) // true

// BEFORE we add the constructor method:
// console.log(flight1.constructor === Flight) // false 
// console.log(flight1.constructor === Object) // true
// AFTER adding the constructor: Flight
console.log(flight1.constructor === Flight) // true
console.log(flight1.constructor === Object) // false

console.log(Object.getPrototypeOf(flight1)) // constructor: Flight(airlines, flightNumber), display: display(), toString: toString() 

```

```js
const obj = {}
const objPrototype = Object.getPrototypeOf(obj)

console.log(objPrototype) // {constructor, hasOwnProperty, isPrototypeOf, propertyIsEnumerable, toString, ...}
console.log(objPrototype === Object.prototype) // true
console.log(Object.prototype.isPrototypeOf(objPrototype)) // true
```

```js
// constructor
function Book(title, author, year) {
  this.title = title
  this.author = author
  this.year = year
  
//   this.getSummary = function() {
//     console.log(`${this.title} (${this.year}) - ${this.author}`)
//   }
}

// Prototype
Book.prototype.getSummary = function() {
  console.log(`${this.title} (${this.year}) - ${this.author}`)
}

Book.prototype.getAge = function() {
  const years = new Date().getFullYear() - this.year
  console.log(`${this.title} is ${years} years old.`)
}

// Change year / manipulate instance data
Book.prototype.revise = function(newYear) {
  this.year = newYear
  this.revised = true
  console.log(`${this.title}'s new year is ${this.year}.`)
}


const book1 = new Book('title 1', 'author 1', 1925)
const book2 = new Book('title 2', 'author 2', 1968)

// console.log(book1.getSummary === book2.getSummary) // false
// console.log(book1.getSummary2 === book2.getSummary2) // true

console.log(book1) /*
Book {...}
  author: "author 1"
  title: "title 1"
  year: 1925
  [[Prototype]]: Object
    getAge: Æ ()
    getSummary: Æ ()
    constructor: Æ ()
    [[Prototype]]: Object
      constructor: Æ Object()
      hasOwnProperty: Æ hasOwnProperty()
      isPrototypeOf: Æ isPrototypeOf()
      ...
*/
```

```js
// use with caution!

String.prototype.display = function() {
  console.log(this, this.toString())
}

'test'.display() // String { "test" }, 'test'
```

<br/><br/>


## Inheritance

### Prototype inheritance

```js
// constructor
function Book(title, author, year) {
  this.title = title
  this.author = author
  this.year = year
}

// Prototype
Book.prototype.getSummary = function() {
  console.log(`${this.title} (${this.year}) - ${this.author}`)
}

// 1. Constructor
function Magazine(title, author, year, month) {
  Book.call(this, title, author, year)
  this.month = month
}

// 2. Inherit Prototype
Magazine.prototype = Object.create(Book.prototype)

// 3. Use own Constructor
Magazine.prototype.constructor = Magazine

const mag1 = new Magazine('Mag One', 'John Doe', 2018, 'Jan')
// mag1.getSummary() // TypeError: mag1.getSummary is not a function (BEFORE inheriting the prototype)
```

**`Object.create()`** - creates an object and assigns it a _prototype_ property of our choice.

```js
const project = { name: 'Road Work' }
// is equivalent to:
Object.create(Object.prototype, {
  name: {
    configurable: true,
    enumerable: true,
    value: 'Road Work',
    writable: false
  }
})
```

**Prototype chaining:**
```js
const project1 = {
  name: 'Road Work',
  display() { console.log(this.name) }
}

const project2 = Object.create(project1, {
  name: {
    configurable: true,
    enumerable: true,
    value: 'Bridge Work',
    writable: false
  }
})

project2.display() // Bridge Work
```

<br/><br/>


### Constructor inheritance

```js

```

<br/><br/>



### Object.create()

```js
var bookPrototypes = {
  getSummary: function() {
  	console.log(`${this.title} (${this.year}) - ${this.author}`)
  },
  
  getAge: function() {
    const years = new Date().getFullYear() - this.year
  	console.log(`${this.title} is ${years} years old.`)
  }
}

var book1 = Object.create(bookPrototypes, {
  title: { value: 'Book One' },
  author: { value: '...'},
  ...
})
// book1.title = '...'
// book1.author = '...'

console.log(book1) // same as above example
```

<br/><br/>


# CLASSES
_The **class** keyword in Javascript is just a Syntactic sugar. And under the hood itâs just a special function. Uses the ES5 JS way of OOP (prototypes, etc.)_

_Function analogue:_
```js
function Holiday(destination, days) {
  this.destination = destination
  this.days = days
}

Holiday.prototype.info = function() { console.log(this.destination + ' | ' + this.days) }

const nepal = new Holiday('Nepal', 30)
nepal.info() // 'Nepal | 30'
```

**Same with Class:**
```js
// SUPER CLASS
class Holiday {  // has a function with a constructor underneath
  constructor(destination, days) { // sets the arguments as properties to the class
    this.destination = destination
    this.days = days
  }

  // methods are added to the Prototype
  info() { console.log(this.destination + ' | ' + this.days)}
}

const trip = new Holiday('Nepal', 30)
trip.info() // 'Nepal | 30'


// SUB CLASS
class Expedition extends Holiday {
  constructor(destination, days, gear) {
    super(destination, days) // calling the parent class and passing the arguments to it
    this.gear = gear
  }

  info() {
    super.info() // calling the parent's info() method
    console.log('Gear:', this.gear.join(' and '))
  }
}

const tripWithGear = new Expedition('Everest', 30, ['sunglasses', 'flags'])
tripWithGear.info() // '... Gear: sunglasses and flags'
```   

<br/>

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields
  
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain

<br/>

> The **class methods** are added to the **prototype**

> **Hoisting** - an important difference between function declarations and class declarations is that while functions can be called in code that appears before they are defined, **classes must be defined before they can be constructed**. 

> Methods can be **overridden**

<br/><br/>

## Getters and Setters
[exercise\typescript\understanding-ts-2022\classes\src\app.ts](..%5Ctypescript%5Cunderstanding-ts-2022%5Cclasses%5Csrc%5Capp.ts)
```ts
class AccountingDepartment extends Department {
  private lastReport

  // getter (allows access to a prop with additional logic) - later executed as a prop, not as a fn
  get mostRecentReport() {
    if (this.lastReport) {
      return this.lastReport
    }
    throw Error('No reports found.')
  }
  
  set mostRecentReport(value: string) {
    if (!value) {
      throw new Error('Please pass in a valid value!')
    }
    this.addReport(value)
  }
  ...
}

// using getter and setter
accounting.mostRecentReport = ''
console.log(accounting.mostRecentReport)
```

<br/>

## Static properties and methods
_They can be used **without instantiating** an object_

- allows adding properties and methods to classes which are **not accessible** to class **instances** but only inside the class itself.
- Usually for **utility** fns and **global constants** for a class. 
- **Cannot be accessed** by the **non-static** parts of the class. 
- in static methods `this` refers to the **class**, while in non-static methods `this` refers to the **instance**
- **No need** for calling `new`. 
- Example: `Math.PI`, `Math.pow()`  

```ts
class Department {
  static fiscalYear = 2022
  static createEmployee(name: string) {
    return { name }
  }

  constructor() {
    this.fiscalYear // cannot be accessed by the constructor
    Department.fiscalYear // now can be accessed
  }
} 

const employee1 = Department.createEmployee('Max')
console.log(employee1, Department.fiscalYear) // {name: 'Max'} 2022
```

<br/><br/><br/>


# SPREAD
```js
someArray.push( ...items )
const copiedPerson = { ...person }
```
<br/><br/>


# REST (parameters)
```js
const fn = (...args) => {}
```
<br/><br/>


# DESTRUCTURING
```js
const [, secondElement] = [1, 2, 3] // 2 

//Can be also used with a DEFAULT value:
const { name: newNameVar, position, age = 55 } = user
```
<br/><br/>


# RESTRUCTURING
```js
const adventureClimbing = {
  name: 'Everest',
  height: 8848,
  output() {
    console.log(`Mt. ${this.name} is now ${this.height} meter tall.`)
  }
  // short for:
  output: function() {
    console.log(`Mt. ${this.name} is now ${this.height} meter tall.`)
  }
}
```
<br/><br/>

# Default parameters

A good practice is to keep all default parameters to the **right**:
```js
function add(a = 4, b) { // bad
function add(a, b = 4) { // good
```
<br/><br/>


# Swapping values
```js
let a = 5;
let b = 10;

[a, b] = [b, a]
```
<br/><br/>


# Generators
```js
function* numberGenerator() {
    yield 1;
    yield 2;
    return 3;
}

let generator = numberGenerator();

let one = generator.next();
let two = generator.next();
let last = generator.next();

console.log(one);    // { value: 1, done: false }
console.log(two);    // { value: 2, done: false }
console.log(last);   // { value: 3, done: true }
```
<br/><br/>

# Asynchronous concepts

Asynchronous programming is a technique that enables your program to start a **potentially long-running task**, and then rather than having to wait until that task has finished, to be able to **continue to be responsive** to other events while the task runs. Once the task is **completed**, your program is presented with the **result**. Examples: `fetch() API`, `XMLHttpRequest`

## Callbacks

> **Callback hell** - when we have a number ot nested callback which become hard to track. Using `Promises` and `async/await` fns is recommended over callbacks

<br/><br/>

## Promises (future values)
_JavaScript is a **single-threaded** language supporting synchronous and asynchronous operations. And promises are just a more elegant way to deal with these asynchronous tasks than callbacks. And a very handy way to avoid callback hell._

**A promise** is an object representing the **current state of asynchronous tasks**, which are tasks that **donât block the execution** until it is finished. This approach is great for time consuming tasks. At the time the promise is returned to the caller, the operation often isn't finished, but the promise object provides **methods to handle** the eventual success or failure of the operation.

With a _callback design_, you call the asynchronous function, passing in your callback function. The function returns immediately and calls your callback when the operation is finished.  
With a _promise-based API_, the asynchronous function **starts the operation and returns a Promise object**. You can then attach **handlers** to this promise object, and these handlers will be executed when the operation has **succeeded** or **failed**.

```js
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json')

console.log(fetchPromise) // Promise { <state>: "pending" }

// When (and if) the fetch operation succeeds, the promise will call our handler, passing in a Response object, which contains the server's response.
fetchPromise.then( response => { 
  console.log(`Received response: ${response.status}`) // Received response: 200
})

console.log("Started request...")
```

A Promise is in one of these **states**:
- **pending**: initial state, neither fulfilled nor rejected.
- **fulfilled**: meaning that the operation was completed successfully and the `then()` handler is called
- **rejected**: meaning that the operation failed and the `catch()` handler is called

### Promises can be **chained**:
```js
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then( response => {
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }
    return response.json()
  })
  .then( data => {
    console.log(data[0].name)
  })
  .catch( error => { // triggered when ANY promise in the chain fails
    console.error(`Could not get products: ${error}`)
  })
```

```js
const getRoleId = new Promise((resolve, reject) => {
  setTimeout(() => resolve('role_1'), 1000)
})

const getRoleDetails = (roleId) => {
  return new Promise((resolve, reject) => {
    setTimeout((id) => resolve('role details for ' + id), 1000, roleId)
  })
}

getRoleId.then(roleId => {
  return getRoleDetails(roleId)
}).then(details => console.log(details))
```

> The **promise class constructor** takes one argument which is a function with two arguments `(resolve, reject` that will be passed to us  

```js
var p = new Promise((resolveFn, rejectFn) => {
  // could be resolved OR rejected
  setTimeout((theParam)=> resolveFn('yeah', theParam), 1000, someParam)
  // setTimeout(()=> rejectFn('ops'), 3000)
})

p
  .then(resolvedMessage => console.log(resolvedMessage))
  .catch(rejectMessage => console.log(rejectMessage))
```

<br/>

### Promises can be **combined**

- **`Promise.all()`** - the promise chain is what you need when your operation consists of several asynchronous functions, and you need each one to complete before starting the next one. Sometimes you need **all** the promises to be fulfilled, but they **don't depend on each other**. In a case like that it's much more efficient to start them all off together, then be notified when they have all fulfilled. The `Promise.all()` method is what you need here. It **takes an array of promises, and **returns a single promise**:
  - **fulfilled** when and if **all** the promises in the array are **fulfilled**. In this case the `then()` handler is called with an array of all the responses, in the same order that the promises were passed into all()
  - **rejected** when and if **any** of the promises in the array are **rejected**. In this case the `catch()` handler is called with the error thrown by the promise that rejected.
  
  ```js
  const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
  const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
  const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

  Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
    .then( responses => {
      for (const response of responses) {
        console.log(`${response.url}: ${response.status}`)
      }
    })
    .catch( error => {
      console.error(`Failed to fetch: ${error}`)
    })
  ```

- **`Promise.any()`** - Sometimes you might need **any** one of a set of promises to be fulfilled, and don't care which one. This is like `Promise.all()`, except that it is fulfilled as soon as **any** of the array of promises is **fulfilled**, or **rejected if all of them are rejected**

<br/><br/>

## ERRORS handling

To support error handling, Promise objects provide a **`catch()`** method. This is a lot like `then()`: you call it and pass in a handler function. However, while the handler passed to then() is called when the asynchronous operation succeeds, the handler passed to catch() is called when the asynchronous operation **fails**.

If you add `catch()` to the **end of a promise chain**, then it will be called when **any** of the asynchronous function calls **fails**.

<br/><br/>


### ERRORS: when there's asynchronicity in a try-catch block
```js
try {
  setTimeout(() => {
    console.bla()
  }, 100)
} catch (e) {
  //...
}
```

_The try-catch block watches for an error in the block within only in the instant that it's executed. As soon as that code is executed, we exit the try-catch block and everything continues as usual. So when the ***asynchronously*** executed function runs, we are already outside of the try-catch block, which leads to an **Uncaught Error**._
<br/><br/>


### Catching async errors (2):

[exercise\react\typescript\jbook\packages\local-api\src\index.ts](..%5Creact%5Ctypescript%5Cjbook%5Cpackages%5Clocal-api%5Csrc%5Cindex.ts)
```js
return new Promise<void>((resolve, reject) => {
  app.listen(port, resolve).on('error', reject)
})
```
And then in [exercise\react\typescript\jbook\packages\cli\src\commands\serve.ts](..%5Creact%5Ctypescript%5Cjbook%5Cpackages%5Ccli%5Csrc%5Ccommands%5Cserve.ts)
```js
//...
.action(async (filename = 'notebook.js', options: { port: string }) => {
    try {
      const dir = path.join(process.cwd(), path.dirname(filename)) // joins current path and relative path of the file (from current)
      await serve(parseInt(options.port), path.basename(filename), dir) // returns a custom Promise so we could catch any async error
    } catch (error) {
      console.log(`Here's the problem: ${error}`)
    }
  })
```
<br/><br/>


## async / await

An async function is a function declared with the async keyword, and the await keyword is permitted within it. The `async` and `await` keywords enable asynchronous, **promise-based behavior to be written in a cleaner style, similar to synchronous code, avoiding the need to explicitly configure promise chains**.

> Produced to **consume** promises instead of creating them

> `async` function continues to run in the **background** without blocking the code

> `await` **stops** the code execution until the `promise` is resolved

```js
const getRoleId = new Promise((resolve, reject) => {
  setTimeout(() => resolve('role_1'), 1000)
})

const getRoleDetails = (roleId) => {
  return new Promise((resolve, reject) => {
    setTimeout((id) => resolve('role details for ' + id), 1000, roleId)
  })
}
```

> We can even use a `try...catch block` for error handling, exactly as we would if the code were synchronous.  

> Note though that async functions **always return a promise**

```js
async function fetchProducts() {
  try {
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json')
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }
    const data = await response.json()
    return data
  }
  catch(error) {
    console.error(`Could not get products: ${error}`)
  }
}

const promise = fetchProducts()
promise.then(data => console.log(data[0].name))
```

> Keep in mind that just like a promise chain, `await` forces asynchronous operations to be **completed in series**. This is necessary if the result of the next operation depends on the result of the last one, but if that's **not** the case something like `Promise.all()` will be **more performant**.


**Conclusion**

**Promises** are the foundation of asynchronous programming in modern JavaScript. They make it easier to express and reason about sequences of asynchronous operations without deeply nested callbacks, and they support a style of error handling that is similar to the synchronous `try...catch` statement.

The `async` and `await` keywords make it easier to build an operation from a series of consecutive asynchronous function calls, **avoiding** the need to create explicit **promise chains**, and allowing you to write code that looks just like synchronous code.

<br/><br/>


# Catching uncaught errors (look also in the Promises section):
```js
// e.g. missed ASYNC errors
window.addEventListener('error', (event) => {
  event.preventDefault() // so the browser doesn't print the error
  console.log('[ERROR]', event.error.message)
})
```
<br/><br/>


# Optional chaining
```js
a?.b // if a ...
```
<br/><br/>


# Nullish coalescing (??)
```js
// ?? - if it's null/undefined
// || - if it's falsy
const userInput = ''
console.log(userInput ?? 'DEFAULT') // ''
console.log(userInput || 'DEFAULT') // 'DEFAULT'
```
<br/><br/>


# Exponential operator (ES7)
```js
let a = 2 ** 3
let b = 3 ** 3
console.log(a === Math.pow(2, 3)) // true
console.log(b === Math.pow(3, 3)) // true
```
<br/><br/>


# Enums & checks
```js
!= null // not null or undefined

// for...of
for (const element of array1) { console.log(element) }

// for...in
if (prop in obj) {...}
for (const property in object) { console.log(`${property}: ${object[property]}`) }

// instanceof
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);
console.log(auto instanceof Car) // true
console.log(auto instanceof Object) // true

// these are primitive types too:
typeof undefined // undefined
typeof null // object (NB! should be checked with `someVar === null` instead)

typeof someFunction // function

typeof someArray // object
typeof someObject // object
// BETTER:
instanceof Array // true
instanceof Object // true
instanceof Function // true
// since all the reference types are children of Object, hence Array/Function instanceof Object -> true
```

<br/><br/>



# IFRAMES

**Direct access between frames is allowed when:**  
 * the iframe element does not have a `sandbox` property or has a `'sandbox="allow-same-origin"` property  

**AND**

 * we fetch the _parent html doc_ and the _frame html doc_ from the **exact same**:
   * domain
   * port
   * protocol  
<br/>

`srcDoc` attribute - specifies the HTML content of the page to show in the inline frame. _Caution: its length could be limited/not allowed in some browsers._

```
<iframe src="data:...untrusted content" sandbox /> <- Secure in modern browsers, insecure in legacy browsers with no sandbox support

<iframe srcDoc="...untrusted content" sandbox /> <- Secure in modern browsers, secure (though non-functional) in legacy browsers
```

`window.postMessage(message, domainsToReceiveIt)` - safely enables **cross-origin communication** between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.

```
// in the parent:
window.addEventListener('message', event => console.log(event), false)

// in the child iframe:
parent.postMessage('hello!', '*')

// log from the parent's listener:
MessageEvent {
  ...
  data: 'hello!'
}
```
<br/><br/>



# USEFUL

## Random ID generation
```js
const randomId = () => Math.random().toString(36).substring(2, 7)
```

<br/>

## Convert to number
`+var`

<br/><br/>


## Symbol

Symbols are new **primitive** type introduced in ES6. Symbols are completely **unique identifiers**. Just like their primitive counterparts (Number, String, Boolean), they can be created using the factory function Symbol() which returns a Symbol. Symbol object props are **not enumerable**

```js
var a = Symbol('test')
var b = Symbol('test')

a === b // false
a // Symbol(test)
a.description // 'test'



const obj = {
  [Symbol('my_key')]  : 1, 
   enum               : 2, 
   nonEnum            : 3
};

Object.defineProperty(obj, 'nonEnum', { enumerable: false }); // Making 'nonEnum' as not enumerable.

// Ignores symbol-valued property keys:
> Object.getOwnPropertyNames(obj)
['enum', 'nonEnum']

// Ignores string-valued property keys:
> Object.getOwnPropertySymbols(obj)
[Symbol(my_key)]

// Considers all kinds of keys:
> Reflect.ownKeys(obj)
[Symbol(my_key),'enum', 'nonEnum']

// Only considers enumerable property keys that are strings:
> Object.keys(obj)
['enum']
```
<br/><br/>


## Bind
```js
class Printer {
  message = 'This works!'

  showMessage() {
    console.log(this.message)
  }
}

const printer = new Printer()
const button = document.querySelector('button')!
// button.addEventListener('click', printer.showMessage) // logs 'undefined', because this -> button
button.addEventListener('click', printer.showMessage.bind(printer)) // now this -> printer
```

# DOM

- `container.current.contains(event.target)` - check if an element is inside another element

- `document.importNode(node: DocumentFragment, deep?: boolean | undefined): DocumentFragment` - Returns a **copy** of a node. If deep is true, the copy also includes the node's descendants.

- `someDomElement.insertAdjacentElement(where: InsertPosition, element: Element): Element | null` - **inserts** a given element node at a given **position** relative to the element it is invoked upon

```html
<template id="template1">
  <div>Test</div>
</template>
<div id="container"></div>
```
```js
const t = document.getElementById('template1')
const deepClone = true
const importedNode = document.importNode(t.content, deepClone)
const element = importedNode.firstElementChild
document.getElementById('container').insertAdjacentElement('afterbegin', element)
```


# Drag & Drop
[exercise\typescript\understanding-ts-2022\project_drag-drop\src](../typescript/understanding-ts-2022/project_drag-drop/src)

```html
<li draggable="true"></li>
```

```js
// DRAGGED element:

liElement.addEventListener('dragstart', (event) => {
  // not all drag events have dataTransfer property
  event.dataTransfer!.setData('text/plain', this.project.id)
  // tells the browser about our intention and changes the cursor to the appropriate shape (move, copy, ...)
  event.dataTransfer!.effectAllowed = 'move'
})

liElement.addEventListener('dragend', (_: DragEvent) => {
  console.log('dragEnd')
})


// DROP TARGET element:

@Autobind
dragOverHandler(event: DragEvent) {
  if (event.dataTransfer?.types[0] === 'text/plain') {
    // tells JS that for this element we want to ALLOW a drop and the drop event will fire now on drop. by default it won't
    event.preventDefault()

    const listEl = this.element.querySelector('ul')!
    listEl.classList.add('droppable')
  }
}

@Autobind
dropHandler(event: DragEvent) {
  const projectId = event.dataTransfer!.getData('text/plain')
  projectState.moveProject(projectId, this.type === 'active' ? ProjectStatus.Active : ProjectStatus.Finished)
}

@Autobind
dragLeaveHandler(_: DragEvent) {
  const listEl = this.element.querySelector('ul')!
  listEl.classList.remove('droppable')
}
```

<br/><br/><br/>


### Import aliases
```js
import a as A from '...'
import * as grouped from '...'

grouped.a, grouped.b
```

> **Code in modules execution**: the code in every module (file) **runs only once**, when it's imported for a first time.

<br/><br/><br/>



# OPTIMIZE AN APP
- use a **bundler** do minimize code, decrease requests for files (production build)
- bundle analyzer - you can find and remove e.g. unused moment.js languages and lodash functions
- **lazy loading** - React.Suspense and React.Lazy
- use **React.Fragment** to avoid adding extra nodes to the dom
- **React.memo** - to re-render only if props change
- **Virtualization** for long flat lists
- **multiple chunk files** - `CommonsChunkPlugin` - separate project and 3rd party libs code - `Vendor.bundle.js` and `app.bundle.js`. The browsers caches these files less frequently and retrieves resources in parallel, reducing load times.
- **throttling** (delay execution) and **debouncing** - to filter frequent events
- use **css animations** instead js animations
- **Redux reselect** - to create memoized selectors


<br/><br/>


# Strict Mode

- **functions** inside blocks are **scoped to blocks**
- all **modules** and **classes** are in **strict mode**
- not allowed to **define global variables** by mistyping the calling of a defined var
- attempts to delete **undeletable** properties throws
- requires regular **function params** to be **unique**
- forbids **setting properties** on **primitive** values
- **duplicate property names** throws
- the **global context** is `undefined`
- assignment to a non-writable **global** or **property**, assignment to a **getter-only** property, assignment to a **new property** on a **non-extensible** object will throw 
- more **secure**

<br/><br/>

# Array methods

- `map` - the map() method creates a new array populated with the results of **calling a provided function on every element** in the calling array

- `reduce` - The reduce() method executes a user-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. 
  ```js
  const array1 = [1, 2, 3, 4];

  // 0 + 1 + 2 + 3 + 4
  const initialValue = 0;
  const sumWithInitial = array1.reduce(
    (previousValue, currentValue) => previousValue + currentValue,
    initialValue
  );

  console.log(sumWithInitial);
  // expected output: 10
  ```
