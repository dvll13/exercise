# EXECUTION CONTEXT & CALL STACK

> Every JS code runs in an environment called **Execution Context**.

- By default every code is in the **Global (Default) Execution Context (GEC)**
- Inside `GEC` all code that is not wrapped in a `function` gets **executed**
- A **new `function`** gets its **new Execution Context**
  
> **Call Stack** - a collection of **all Execution Contexts**, where they **pile up** for each `function` call and are **removed** when the function returns. At the bottom is the **GEC**.

<br/>

### Execution Context Object contains 3 properties:
- **Variable Object** - contains function arguments, inner variable declarations, function declarations   
- **Scope chain** - contains the current variable objects, as well as variable objects of all its parents
- **`this` keyword/variable** - a var that each execution context gets

<br/>

### Execution Context Object PHASES:
- **Creation** phase:
  - creation of the **variable object**
    - the **`arguments`** object is created, containing all the arguments passed to the function
    - next is **HOISTING**:
      - code is scanned for **`function` declarations** and for each one, a property is created in the **variable object**, pointing to its function, so`functions` are made available **before** the execution phase starts
      - code is scanned for **`variable` declarations** and for each a property is created in the **variable object** and set to `undefined`, and will be defined in the `execution` phase
  - creation of the **scope chain**
  - determine the value of the **`this` variable**
- **Execution** phase - the code of the function that was generated by the current execution context is ran line by line

<br/>

### Scoping

> **Scope** - space/environment where a certain **variable** is declared and can be accessed

> **Lexical Scoping** - scoping is controlled by the **placement** of `functions` and `blocks` in the code

- **Global** scope - **outside** of any function or block. Variables declared in it are **global**
- **Function** / **Local** scope - each `function` creates a scope and the variables declared there are only accessible in it
- **Block** scope - from ES6, blocks `{...}` create a scope also
  - `let` and `const` variables (block scoped), declared in a Block scope, are accessible **only** inside it
  - `vars` (function scoped) though are scoped to the current `Function` or `Global` scope
  - in `strict mode` all `functions` are **block scoped** too

<br/>

### Scope Chain

 > **Variable Lookup** - if a variable can't be found in the current scope, the JS engine starts looking for it in the **parent scope**, then its parent scope, and so on (up in the Scope Chain).

<br/>

### `this` keyword

- in a **regular `function` call**: points to the **global** `window` object
- in a **method (fn attached to an object) call**: 
  - **regular** function - points to the **`object`** that is **calling** the method 
  - **arrow** function - points to the **upper** context 

In a Method	Owner             Object(Which invoked method)
Alone                         Global Object
In a function (Default Mode)	Global Object
In a function (Strict Mode)	  undefined
In an event	                  the target of the event

  ```js
  const obj1 = {
    a: 1,
    b: this.a,
    f1() { console.log(this.a, obj1.a, this.b, this) } // 1 1 undefined {...obj1}
    f2: function() {
      console.log(this) // { ...obj1 }
      
      function f() { console.log(this) } // function declaration
      f() // it's a regular fn call => Window 
      
      const fn = function() {} // function expression
    }, 
    f3() { console.log(this) }, // { ...obj1 }
    f4: () => { console.log(this) }, // Window
  }

  // method borrowing:
  var obj2 = { a: 2 }
  obj2.f1 = obj1.f1
  obj2.f1() // 2 1 undefined {..obj2s}
  ```

- `this` is **not assigned** a value until the function where it is defined is **called**

> A **constructor** is a fn that allows us to create a blueprint, based on which we can create instances using the **`new`** keyword. In the `constructor` the `this` keyword refers to the newly created `object`.
> 
```js
// construction function should start with a capital letter
const SomeConstructorFn = function (firstProp, secondProp) {
  this.firstProp = firstProp
  this.secondProp = secondProp
}

const obj1 = new SomeConstructorFn('first', 2) // => obj1 { firstProp: "first", secondProp: 2 }
```

[eyeballing this](https://gist.github.com/zcaceres/2a4ac91f9f42ec0ef9cd0d18e4e71262)

<br/><br/><br/>

# Primitive and reference types

```js
// these are primitive types too:
typeof undefined // undefined
typeof null // object (NB! should be checked with `someVar === null` instead)

typeof someFunction // function

typeof someArray // object
typeof someObject // object
// BETTER:
instanceof Array // true
instanceof Object // true
instanceof Function // true
// since all the reference types are children of Object, hence Array/Function instanceof Object -> true
```

> **De-referencing** an object - when we **remove** all pointers to a memory allocated space for an object, then the JS engine will clean it from the memory (garbage collect). This can be done by **`obj1 = null`**.

> **Wrapper types** for primitive values - JS uses them to allow us to call methods on them like `someString.substring()`. Adds the wrapper when it notices the method call and destroys it immediately, that's why `someString instanceof String === false`

<br/><br/><br/>

# Equality (===)

> `==` - converts the type of the right part to the left and then compares

> `===` compares the value **and the type**

<br/><br/><br/>


# CLOSURE
_allows an inner function to to have access to the outer function's variables and use them as "private" ones_
```js
const getAdd = () => {
  let foo = 1
  
  return () => {
    foo = foo + 1
    return foo
  }
}

const add = getAdd()

OR:

const add = (const getAdd = () => {
  let foo = 1
  
  return () => {
    foo = foo + 1
    return foo
  }
})() // Immediately Invoked Function Expression (IIFE)

===

console.log(add()) // 2
console.log(add()) // 3
console.log(add()) // 4
```	
<br/><br/>


# VARS
- `let`, `const` -> scoped in the current context (block-scoped variables), unlike `var`  
- `var` variables can be redeclared multiple times without causing an error, unlike `let` and `const`; they have **global and function** scopes
<br/><br/>


# FUNCTIONS

There are 2 ways to **define** them:
  - **declaration** - `function a() {...}` -> **hoisting** (js engine pushes it to the top of the scope)
  - **expression** - `const a = function() {...}` -> **no hoisting** because the js engine doesn't know the name of the function ahead of time

> **`arguments`** - stores all passed params even if they are not declared

> **`someFunction.length`** - returns the number of **named** params

- **`call()`** - `someFunc.call(objectToPassToThis, ...arguments)`, no params -> passes the global scope to `this`. Allows a function to be defined outside of the objects that will invoke it
- **`apply()`** -  `someFunc.call(objectToPassToThis, [...arguments])` - same as `call` but the only difference is that it accepts an array of arguments instead of passing them one by one
- **`bind()`** - `const boundFn = fn.bind(obj1, ...args)` - returns a function in which `this = obj1`; `args` could also be passed to the `boundFn`
<br/><br/>


# ARROW FUNCTIONS
_anonymous function assigned to a variable_

They don't have their own context (`this` points to the upper enclosing context).  
A function becomes a part of the global window context, so with an arrow function `this` points to it.

Arrow functions handle `this` in a different way from regular functions:
* Arrow function - `this` represents the object that **defined** the arrow function.  
* In regular functions this keyword represented the object that **called** the function (the executer), which could be the window, the document, or whatever.

In short , in arrow function this represents the **definition** context while in regular function this represents the **execution** context.

```js
const obj = {
  props: ['prop1', 'prop2'], 
  
  printProps: function() {
    console.log(this) // this -> obj (since the function is part of the object)
    
    setTimeout(function() { 
      console.log(this) // this -> window
    }, 1000)

    setTimeout(() => console.log(this), 2000) // this -> obj
  },

  printPropsA: () => {
    console.log(this) // this -> window
    
    setTimeout(function() { 
      console.log(this) // this -> window
    }, 1000)

    setTimeout(() => console.log(this), 2000) // this -> window
  }
}
```

> Arrow functions **CANNOT** be used as **constructors** : 
This is because of how Arrow Functions use the `this` keyword. JS will simply throw an error if it sees an arrow function being invoked as a "constructor".

```js
function personCreator(name) {
   this.name = name
}
const person1 = new personCreator('John') // personCreator {name: 'John'}
```

The `new` keyword do some of its magic and makes the `this` keyword that is inside of `personCreator` to be initially an empty object instead of referencing the global object. After that, a new property called `name` is created inside that empty this object, and its value will be `'John'`. At the end, the `this` object is returned.

As we see, the `new` keyword changed the value of `this` from referencing the `global` object to `now` be an empty object `{}`.

**Arrow functions do not allow their `this` object to be modified**. Their `this` object is **always** locked to the value of the `this` of the scope where they were statically **created**. This is called **Static Lexical Scope**. That is why you **cannot** do operations like `bind`, `apply`, or `call` with arrow functions. 

_A **lexical scope** is just the area where a function is created._

- `this` keywords specifics from above
- Also **no `arguments`** keyword  
- No **`new`** keyword

Arrow functions **don't have** their own `this` or `arguments` binding. Instead, those identifiers are resolved in the **lexical scope** like any other variable. That means that inside an arrow function, `this` and `arguments` refer to the values of `this` and `arguments` in the environment the arrow function is **defined**

<br/><br/>


# REGULAR (R) VS ARROW (A) FUNCTIONS

- **syntax**
- **no `this` and `arguments` binding in A** - they are resolved in the lexical scope like any other variable (the env in which the A is defined)
- **`new` keyword** - **R** are **constructible** and they can be called with the `new` keyword
- **no duplicate params** in **A**, while **R** allow it if not in `strict mode`

[https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-interchangeable](https://stackoverflow.com/questions/34361379/are-arrow-functions-and-functions-equivalent-interchangeable)

<br/><br/>

# OBJECTS

> **`obj1.hasOwnProperty('prop1')`** method - check if a property is present and **not inherited**

> **`delete obj.prop`** - delete a property, returns `true` if it's deleted and `false` otherwise

> **`obj1.propertyIsEnumerable('prop1')`**- not all props are enumerable (get cycled in loops), can be checked with this method


## Accessors
```js
var a = {
  _name: 'one',
  _second: 'once',
  set name(value) { this._name = value },
  get name() { return this._name }
}

console.log(a.second) // undefined
console.log(a.name) // one
a.name = 'two'
console.log(a.name) // two
```

> If only a **getter** is defined, then the prop will be **read-only**.


## Property descriptors
> they allow to define an object property in more detail.  

<br/>

> `Object.defineProperty(obj1, prop, descriptor): obj1` - This method allows a precise **addition to or modification of a property** on an object. Normal property addition through assignment creates properties which show up during property enumeration (`for...in` loop or `Object.keys` method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults. By default, values added using `Object.defineProperty()` are immutable and not enumerable.



```js
const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false
});

object1.property1 = 77;
// throws an error in strict mode

console.log(object1.property1);
// expected output: 42
```
<br/>

Property descriptors present in objects come in two main flavors: **data descriptors** and **accessor descriptors**. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions.  
<br/>

Both data and accessor descriptors are objects. They share the following **optional keys**:
- `configurable` [false]
  - the **type** of this property cannot be changed between data property and accessor property
  - the property may not be **deleted**
  - other **attributes of its descriptor** cannot be changed (however, if it's a data descriptor with `writable: true`, the value can be changed, and `writable` can be changed to `false`)
  - once set to `true` **can't be changed back** to `false`
- `enumerable` [false] - should this property shows up during enumeration of the properties on the corresponding object
- `value` [undefined] - the value of the property
- `writable` [false] - should the value associated with the property may be changed with an assignment operator  

**Accessor** descriptor **additional** keys:
- `get`
- `set`

```js
const o = {}; 
const bValue = 38;

Object.defineProperty(o, 'b', {
  get() { return bValue; },
  set(newValue) { bValue = newValue; },
  enumerable: true,
  configurable: true
});

o.b; // 38
o.b = 22 // Uncaught TypeError: Assignment to constant variable.
```
> A **method** is a property with a function as a value.
```js
{ get: function()  <=> get() {} }
```

<br/><br/>


# Constructor

> A function using which we can **create objects** with the same properties and methods

```js
function FlightNoParams() {}
function Flight(airlines, flightNumber) {
  this.airlines = airlines
  this.flightNumber = flightNumber
  this.display = function() { console.log(this.airlines, this.flightNumber) }

  // Object.defineProperty() can be used in the constructor
}

const flight1 = new FlightNoParams // parenthesis can be omitted when there are no params
const flight2 = new Flight('American Airlines', 'AA123')
console.log(flight2 instanceof Flight) // true
console.log(flight2.constructor === Flight) // true
```

<br/><br/>


# Prototypes

> Every **function** has a reference type property called `prototype` and if we create `objects` using this `function` they will have a property `prototype` that will point to the `function`'s `prototype`.

**Advantages**:
- if we save a method in the `prototype` of the `function` then the `objects` using it will point to it and **save memory**. we can reuse methods and properties on the prototypes
- we can use **prototype chaining** to implement **inheritance**

```js
const passenger = { name: 'John' }

console.log('name' in passenger) // true
console.log(passenger.hasOwnProperty('name')) // true
console.log('hasOwnProperty' in passenger) // true
console.log(passenger.hasOwnProperty('hasOwnProperty')) // false - because it comes from the Object.prototype.hasOwnProperty(). Every object gets access to it.
console.log(Object.prototype.hasOwnProperty('hasOwnProperty')) // true
```

When an object prop is called JS Engine first checks for it in the **object**, then the **prototype** and if still not found, returns `undefined`.

```js
function Flight(airlines, flightNumber) {
  this.airlines = airlines
  this.flightNumber = flightNumber
  // this.display = function() { console.log(this.airlines, this.flightNumber) }
}

// moving the function to the prototype to save memory
// Flight.prototype.display = function() { console.log(this.airlines, this.flightNumber) }
Flight.prototype = {
  constructor: Flight, // good practice
  display: function() { console.log(this.airlines, this.flightNumber) },
  toString: function() {console.log(`Flight ${this.flightNumber}!`)}
}

var flight1 = new Flight('American Airlines', 'AA123')
var flight2 = new Flight('South West', 'SW123')

console.log(flight1.display === flight2.display) // true
console.log(flight1.toString()) // Flight AA123!

console.log(flight1 instanceof Flight) // true

// BEFORE we add the constructor method:
// console.log(flight1.constructor === Flight) // false 
// console.log(flight1.constructor === Object) // true
// AFTER adding the constructor: Flight
console.log(flight1.constructor === Flight) // true
console.log(flight1.constructor === Object) // false

console.log(Object.getPrototypeOf(flight1)) // constructor: Flight(airlines, flightNumber), display: display(), toString: toString() 

```

```js
var obj = {}
var objPrototype = Object.getPrototypeOf(obj)

console.log(objPrototype) // {constructor, hasOwnProperty, isPrototypeOf, propertyIsEnumerable, toString, ...}
console.log(objPrototype === Object.prototype) // true
console.log(Object.prototype.isPrototypeOf(objPrototype)) // true
```

```js
// use with caution!

String.prototype.display = function() {
  console.log(this, this.toString())
}

'test'.display() // String { "test" }, 'test'
```

<br/><br/>


# SPREAD
```js
someArray.push( ...items )
const copiedPerson = { ...person }
```
<br/><br/>


# REST (parameters)
```js
const fn = (...args) => {}
```
<br/><br/>


# DESTRUCTURING
```js
const [, secondElement] = [1, 2, 3] // 2 

//Can be also used with a DEFAULT value:
const { name: newNameVar, position, age = 55 } = user
```
<br/><br/>


# RESTRUCTURING
```js
const adventureClimbing = {
  name: 'Everest',
  height: 8848,
  output() {
    console.log(`Mt. ${this.name} is now ${this.height} meter tall.`)
  }
  // short for:
  output: function() {
    console.log(`Mt. ${this.name} is now ${this.height} meter tall.`)
  }
}
```
<br/><br/>


# CLASSES
_The **class** keyword in Javascript is just a Syntactic sugar. And under the hood it’s just a special function._

## Function analogue:
```js
function Holiday(destination, days) {
  this.destination = destination
  this.days = days
}

Holiday.prototype.info = function() { console.log(this.destination + ' | ' + this.days) }

const nepal = Holiday('Nepal', 30)
nepal.info() // 'Nepal | 30'
```


## Class:
```js
// SUPER CLASS
class Holiday {  // has a function with a constructor underneath
  constructor(destination, days) { // sets the arguments as properties to the class
    this.destination = destination
    this.days = days
  }

  info() { console.log(this.destination + ' | ' + this.days)}
}

const trip = new Holiday('Nepal', 30)
trip.info() // 'Nepal | 30'


// SUB CLASS
class Expedition extends Holiday {
  constructor(destination, days, gear) {
    super(destination, days) // calling the parent class and passing the arguments to it
    this.gear = gear
  }

  info() {
    super.info() // calling the parent info() method
    console.log('Gear:', this.gear.join(' and '))
  }
}

const tripWithGear = new Expedition('Everest', 30, ['sunglasses', 'flags'])
tripWithGear.info() // '... Gear: sunglasses and flags'
```   

<br/>

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields
  
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain

<br/>

> **Hoisting** - an important difference between function declarations and class declarations is that while functions can be called in code that appears before they are defined, classes must be defined before they can be constructed. 

> Methods can be **overridden**

<br/><br/>

## Getters and Setters
[exercise\typescript\understanding-ts-2022\classes\src\app.ts](..%5Ctypescript%5Cunderstanding-ts-2022%5Cclasses%5Csrc%5Capp.ts)
```ts
class AccountingDepartment extends Department {
  private lastReport

  // getter (allows access to a prop with additional logic) - later executed as a prop, not as a fn
  get mostRecentReport() {
    if (this.lastReport) {
      return this.lastReport
    }
    throw Error('No reports found.')
  }
  
  set mostRecentReport(value: string) {
    if (!value) {
      throw new Error('Please pass in a valid value!')
    }
    this.addReport(value)
  }
  ...
}

// using getter and setter
accounting.mostRecentReport = ''
console.log(accounting.mostRecentReport)
```

<br/>

## Static properties

- allows adding properties and methods to classes which are **not accessible** to class **instances** but only inside the class itself.
- Usually for **utility** fns and **global constants** for a class. 
- **Cannot be accessed** by the **non-static** parts of the class. 
- in static methods `this` refers to the **class**, while in non-static methods `this` refers to the **instance**
- **No need** for calling `new`. 
- Example: Math.PI, Math.pow()  

```ts
class Department {
  static fiscalYear = 2022
  static createEmployee(name: string) {
    return { name }
  }

  constructor() {
    this.fiscalYear // cannot be accessed by the constructor
    Department.fiscalYear // now can be accessed
  }
} 

const employee1 = Department.createEmployee('Max')
console.log(employee1, Department.fiscalYear) // {name: 'Max'} 2022
```

<br/><br/><br/>

# Default parameters

A good practice is to keep all default parameters to the **right**:
```js
function add(a = 4, b) { // bad
function add(a, b = 4) { // good
```
<br/><br/>


# Swapping values
```js
let a = 5;
let b = 10;

[a, b] = [b, a]
```
<br/><br/>


# Generators
```js
function* numberGenerator() {
    yield 1;
    yield 2;
    return 3;
}

let generator = numberGenerator();

let one = generator.next();
let two = generator.next();
let last = generator.next();

console.log(one);    // { value: 1, done: false }
console.log(two);    // { value: 2, done: false }
console.log(last);   // { value: 3, done: true }
```
<br/><br/>

# Asynchronous concepts

Asynchronous programming is a technique that enables your program to start a **potentially long-running task**, and then rather than having to wait until that task has finished, to be able to **continue to be responsive** to other events while the task runs. Once the task is **completed**, your program is presented with the **result**.

## Callbacks

> **Callback hell** - when we have a number ot nested callback which become hard to track. Using `Promises` and `async/await` fns is recommended over callbacks

<br/><br/>

## Promises (future values)
_JavaScript is a **single-threaded** language supporting synchronous and asynchronous operations. And promises are just a more elegant way to deal with these asynchronous tasks than callbacks. And a very handy way to avoid callback hell._

> A promise is an object representing the result of asynchronous tasks which are tasks that **don’t block the execution** until it is finished. This approach is great for time consuming tasks.

A Promise is a **proxy for a value** not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.

A Promise is in one of these **states**:
- pending: initial state, neither fulfilled nor rejected.
- fulfilled: meaning that the operation was completed successfully.
- rejected: meaning that the operation failed.

Promises can be **chained**

> The **promise class constructor** takes one argument which is a function with two arguments `(resolve, reject` that will be passed to us  

```js
var p = new Promise((resolveFn, rejectFn) => {
  // could be resolved OR rejected
  setTimeout((theParam)=> resolveFn('yeah', theParam), 1000, someParam)
  // setTimeout(()=> rejectFn('ops'), 3000)
})

p
  .then(resolvedMessage => console.log(resolvedMessage))
  .catch(rejectMessage => console.log(rejectMessage))
```
<br/>

**Promise chain:**
```js
const getRoleId = new Promise((resolve, reject) => {
  setTimeout(() => resolve('role_1'), 1000)
})

const getRoleDetails = (roleId) => {
  return new Promise((resolve, reject) => {
    setTimeout((id) => resolve('role details for ' + id), 1000, roleId)
  })
}

getRoleId.then(roleId => {
  return getRoleDetails(roleId)
}).then(details => console.log(details))
```

<br/><br/>



## ERRORS: when there's asynchronicity in a try-catch block
```js
try {
  setTimeout(() => {
    console.bla()
  }, 100)
} catch (e) {
  //...
}
```

_The try-catch block watches for an error in the block within only in the instant that it's executed. As soon as that code is executed, we exit the try-catch block and everything continues as usual. So when the ***asynchronously*** executed function runs, we are already outside of the try-catch block, which leads to an **Uncaught Error**._
<br/><br/>


## Catching async errors (2):

[exercise\react\typescript\jbook\packages\local-api\src\index.ts](..%5Creact%5Ctypescript%5Cjbook%5Cpackages%5Clocal-api%5Csrc%5Cindex.ts)
```js
return new Promise<void>((resolve, reject) => {
  app.listen(port, resolve).on('error', reject)
})
```
And then in [exercise\react\typescript\jbook\packages\cli\src\commands\serve.ts](..%5Creact%5Ctypescript%5Cjbook%5Cpackages%5Ccli%5Csrc%5Ccommands%5Cserve.ts)
```js
//...
.action(async (filename = 'notebook.js', options: { port: string }) => {
    try {
      const dir = path.join(process.cwd(), path.dirname(filename)) // joins current path and relative path of the file (from current)
      await serve(parseInt(options.port), path.basename(filename), dir) // returns a custom Promise so we could catch any async error
    } catch (error) {
      console.log(`Here's the problem: ${error}`)
    }
  })
```
<br/><br/>


## async/await

An async function is a function declared with the async keyword, and the await keyword is permitted within it. The async and await keywords enable asynchronous, **promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains**.

> Produced to **consume** promises instead of creating them

> `async` function continues to run in the **background** without blocking the code

> `await` **stops** the code execution until the `promise` is resolved

```js
const getRoleId = new Promise((resolve, reject) => {
  setTimeout(() => resolve('role_1'), 1000)
})

const getRoleDetails = (roleId) => {
  return new Promise((resolve, reject) => {
    setTimeout((id) => resolve('role details for ' + id), 1000, roleId)
  })
}


```

<br/><br/>


# Catching uncaught errors (look also in the Promises section):
```js
// e.g. missed ASYNC errors
window.addEventListener('error', (event) => {
  event.preventDefault() // so the browser doesn't print the error
  console.log('[ERROR]', event.error.message)
})
```
<br/><br/>


# Optional chaining
```js
a?.b // if a ...
```
<br/><br/>


# Nullish coalescing (??)
```js
// ?? - if it's null/undefined
// || - if it's falsy
const userInput = ''
console.log(userInput ?? 'DEFAULT') // ''
console.log(userInput || 'DEFAULT') // 'DEFAULT'
```
<br/><br/>


# Exponential operator (ES7)
```js
let a = 2 ** 3
let b = 3 ** 3
console.log(a === Math.pow(2, 3)) // true
console.log(b === Math.pow(3, 3)) // true
```
<br/><br/>


# Enums & checks
```js
!= null // not null or undefined

// for...of
for (const element of array1) { console.log(element) }

// for...in
if (prop in obj) {...}
for (const property in object) { console.log(`${property}: ${object[property]}`) }

// instanceof
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);
console.log(auto instanceof Car) // true
console.log(auto instanceof Object) // true
```

<br/><br/>



# IFRAMES

**Direct access between frames is allowed when:**  
 * the iframe element does not have a `sandbox` property or has a `'sandbox="allow-same-origin"` property  

**AND**

 * we fetch the _parent html doc_ and the _frame html doc_ from the **exact same**:
   * domain
   * port
   * protocol  
<br/>

`srcDoc` attribute - specifies the HTML content of the page to show in the inline frame. _Caution: its length could be limited/not allowed in some browsers._

```
<iframe src="data:...untrusted content" sandbox /> <- Secure in modern browsers, insecure in legacy browsers with no sandbox support

<iframe srcDoc="...untrusted content" sandbox /> <- Secure in modern browsers, secure (though non-functional) in legacy browsers
```

`window.postMessage(message, domainsToReceiveIt)` - safely enables **cross-origin communication** between Window objects; e.g., between a page and a pop-up that it spawned, or between a page and an iframe embedded within it.

```
// in the parent:
window.addEventListener('message', event => console.log(event), false)

// in the child iframe:
parent.postMessage('hello!', '*')

// log from the parent's listener:
MessageEvent {
  ...
  data: 'hello!'
}
```
<br/><br/>


# DOM

`container.current.contains(event.target)` - check if an element is inside another element
<br/><br/>


# USEFUL

## Debounce by useEffect
```
  useEffect(() => {
    const timer = setTimeout(async () => {
      const output = await bundle(input)
      setCode(output)
    }, 1000)

    // the cleanup fn will be called the next time the useEffect is called and will clear the previous timer
    return () => {
      clearTimeout(timer)
    }
  }, [input])
```
<br/><br/>


## Random ID generation
```
const randomId = () => Math.random().toString(36).substring(2, 7)
```

<br/>

## Convert to number
`+var`

<br/><br/>


## Symbol

Symbols are new **primitive** type introduced in ES6. Symbols are completely **unique identifiers**. Just like their primitive counterparts (Number, String, Boolean), they can be created using the factory function Symbol() which returns a Symbol. Symbol object props are **not enumerable**

```js
var a = Symbol('test')
var b = Symbol('test')

a === b // false
a // Symbol(test)
a.description // 'test'



const obj = {
  [Symbol('my_key')]  : 1, 
   enum               : 2, 
   nonEnum            : 3
};

Object.defineProperty(obj, 'nonEnum', { enumerable: false }); // Making 'nonEnum' as not enumerable.

// Ignores symbol-valued property keys:
> Object.getOwnPropertyNames(obj)
['enum', 'nonEnum']

// Ignores string-valued property keys:
> Object.getOwnPropertySymbols(obj)
[Symbol(my_key)]

// Considers all kinds of keys:
> Reflect.ownKeys(obj)
[Symbol(my_key),'enum', 'nonEnum']

// Only considers enumerable property keys that are strings:
> Object.keys(obj)
['enum']
```
<br/><br/>


## Bind
```js
class Printer {
  message = 'This works!'

  showMessage() {
    console.log(this.message)
  }
}

const printer = new Printer()
const button = document.querySelector('button')!
// button.addEventListener('click', printer.showMessage) // logs 'undefined', because this -> button
button.addEventListener('click', printer.showMessage.bind(printer)) // now this -> printer
```

# DOM
- `document.importNode(node: DocumentFragment, deep?: boolean | undefined): DocumentFragment` - Returns a **copy** of a node. If deep is true, the copy also includes the node's descendants.

- `someDomElement.insertAdjacentElement(where: InsertPosition, element: Element): Element | null` - **inserts** a given element node at a given **position** relative to the element it is invoked upon

```html
<template id="template1">
  <div>Test</div>
</template>
<div id="container"></div>
```
```js
const t = document.getElementById('template1')
const deepClone = true
const importedNode = document.importNode(t.content, deepClone)
const element = importedNode.firstElementChild
document.getElementById('container').insertAdjacentElement('afterbegin', element)
```


# Drag & Drop
[exercise\typescript\understanding-ts-2022\project_drag-drop\src](../typescript/understanding-ts-2022/project_drag-drop/src)

```html
<li draggable="true"></li>
```

```js
// DRAGGED element:

liElement.addEventListener('dragstart', (event) => {
  // not all drag events have dataTransfer property
  event.dataTransfer!.setData('text/plain', this.project.id)
  // tells the browser about our intention and changes the cursor to the appropriate shape (move, copy, ...)
  event.dataTransfer!.effectAllowed = 'move'
})

liElement.addEventListener('dragend', (_: DragEvent) => {
  console.log('dragEnd')
})


// DROP TARGET element:

@Autobind
dragOverHandler(event: DragEvent) {
  if (event.dataTransfer?.types[0] === 'text/plain') {
    // tells JS that for this element we want to ALLOW a drop and the drop event will fire now on drop. by default it won't
    event.preventDefault()

    const listEl = this.element.querySelector('ul')!
    listEl.classList.add('droppable')
  }
}

@Autobind
dropHandler(event: DragEvent) {
  const projectId = event.dataTransfer!.getData('text/plain')
  projectState.moveProject(projectId, this.type === 'active' ? ProjectStatus.Active : ProjectStatus.Finished)
}

@Autobind
dragLeaveHandler(_: DragEvent) {
  const listEl = this.element.querySelector('ul')!
  listEl.classList.remove('droppable')
}
```

<br/><br/><br/>


### Import aliases
```js
import a as A from '...'
import * as grouped from '...'

grouped.a, grouped.b
```

> **Code in modules execution**: the code in every module (file) **runs only once**, when it's imported for a first time.

<br/><br/><br/>



# OPTIMIZE AN APP
- use a **bundler** do minimize code, decrease requests for files (production build)
- bundle analyzer - you can find and remove e.g. unused moment.js languages and lodash functions
- **lazy loading** - React.Suspense and React.Lazy
- use **React.Fragment** to avoid adding extra nodes to the dom
- **React.memo** - to re-render only if props change
- **Virtualization** for long flat lists
- **multiple chunk files** - `CommonsChunkPlugin` - separate project and 3rd party libs code - `Vendor.bundle.js` and `app.bundle.js`. The browsers caches these files less frequently and retrieves resources in parallel, reducing load times.
- **throttling** (delay execution) and **debouncing** - to filter frequent events
- use **css animations** instead js animations
- **Redux reselect** - to create memoized selectors


<br/><br/>


# Strict Mode

- **functions** inside blocks are **scoped to blocks**
- all **modules** and **classes** are in **strict mode**
- not allowed to **define global variables** by mistyping the calling of a defined var
- attempts to delete **undeletable** properties throws
- requires regular **function params** to be **unique**
- forbids **setting properties** on **primitive** values
- **duplicate property names** throws
- the **global context** is `undefined`
- assignment to a non-writable **global** or **property**, assignment to a **getter-only** property, assignment to a **new property** on a **non-extensible** object will throw 
- more **secure**